# registers r0-r31
# special purpose register group 0
# supervision register
# no FPU
# no MMU
# no vector math
# no exceptions (yet)
#
# Basic opcode pattern:
# 
# 31     24      16      8       0
# MSB                          LSB
# 33222222222211111111110000000000
# 10987654321098765432109876543210
# --------------------------------
# OOOOOODDDDDAAAAABBBBB???????????
#  or
# OOOOOONNNNNNNNNNNNNNNNNNNNNNNNNN
#  or
# OOOOOO??????????KKKKKKKKKKKKKKKK
#  or some other variation
#
# O = top 6 bits, main opcode group
# D = destination reg
# A = register A
# B = register B
# N = often a signed offset i.e. jump instruction
# K = immediate value
# H = often part of opcode
# L = often part of opcode
# 
# Just to make things clear, opcode definitions will list the bit fields.
# Bitfields cannot cover bits 31-26 because those are part of the main opcode group.
# D is assumed to be bits 25-21 unless otherwise defined.
# A is assumed to be bits 20-16 unless otherwise defined.
# B is assumed to be bits 15-11 unless otherwise defined.
# N is assumed to be bits 25-0 unless otherwise defined.
# I is assumed to be bits 15-0 unless otherwise defined.
# K is assumed to be bits 15-0 unless otherwise defined.
# O is always bits 31-26 and 6 bits wide.
# OT16 is always bits 31-16.
# OT32 is always bits 31-0.
# Bitfields not listed are assumed don't care/reserved (listed with - in the OpenRISC spec)
# FLAG = flag register
# PC = program counter
# PCNEXT = program counter after execution (perhaps even after delay slot)
# NPC = PC + (signextend(N) << 2) (l.j)
# IPAGE = PC + (signextend(I) << 13) (l.adrp)
# param order is often dest, src...
# 
# opcode "name" { ... };
# with/output/input/display { ... };
# input A, B=C, ...
# description "string"
# bit(N) bit N
# bits(msb,lsb)  bit range msb to lsb inclusive
# signed(I)      I sign-extended
# HI16(N)        N << 16                        (l.movhi)
# HI16(N,D)      (N << 16) | (D & 0xFFFFu)      (l.movhi)
# LR is Link Register (r9)
# MACHI, MACLO = multiply-accumulate registers
# I(N) = N + signed(I)

opcode "l.j" {
    with { O=0x00, N };
    output { PC=NPC };
    input { N, PC };
    display { output }; /* l.j <addr> */
    description "Jump";
};

opcode "l.jal" {
    with { O=0x01, N };
    output { PC=NPC };
    input { N, PC };
    display { output }; /* l.jal <addr> */
    description "Jump and Link";
};

opcode "l.adrp" {
    with { O=0x02, D, I=bits(20,0) };
    output { D=IPAGE };
    input { IPAGE, PC };
    display { D, IPAGE }; /* l.adrp rD, <addr> */
    description "Compute Instruction Relative Address";
};

opcode "l.bnf" {
    with { O=0x03, N };
    output { PC=NPC }; /* conditional on !FLAG */
    input { N, PC, FLAG };
    display { output }; /* l.bnf <addr> */
    description "Branch if No Flag";
};

opcode "l.bf" {
    with { O=0x04, N };
    output { PC=NPC }; /* conditional on FLAG */
    input { N, PC, FLAG };
    display { output }; /* l.bf <addr> */
    description "Branch if Flag";
};

opcode "l.nop" {
    with { O=0x05, K };
    display { K }; /* l.nop N */
    description "No Operation";
};

opcode "l.movhi" {
    with { O=0x06, D, bit(16)=0, K };
    output { D=HI16(K,D) };
    input { K, D };
    display { D, HI16(K) }; /* l.movhi rD, HI16(K) */
    description "Move Immediate High";
};

opcode "l.sys" {
    with { OT16=0x2000, O=0x08, K };
    input { K };
    display { K };
    description "System Call";
};

opcode "l.trap" {
    with { OT16=0x2100, O=0x08, K };
    input { K };
    display { K };
    description "Trap";
};

opcode "l.msync" {
    with { OT32=0x22000000, O=0x08 };
    description "Memory Synchronization";
};

opcode "l.psync" {
    with { OT32=0x22800000, O=0x08 };
    description "Memory Synchronization";
};

opcode "l.csync" {
    with { OT32=0x23000000, O=0x08 };
    description "Memory Synchronization";
};

opcode "l.rfe" {
    with { O=0x09 };
    description "Return From Exception";
};

opcode "l.jr" {
    with { O=0x11, B };
    input { B };
    output { PC=B };
    display { B };
    description "Jump Register";
};

opcode "l.jalr" {
    with { O=0x12, B };
    input { B };
    output { LR=PCNEXT, PC=B }; /* order is important here! LR=PCNEXT, then PC=B */
    display { B };
    description "Jump and Link Register";
};

opcode "l.maci" {
    with { O=0x13, A, I };
    input { A, I };
    output { MACHI, MACLO };
    display { A, signed(I) };
    description "Multiply Immediate and Accumulate Signed";
};

opcode "l.lwa" {
    with { O=0x1B, D, A, I };
    input { I, A };
    output { D };
    display { D, I(A) };
    description "Load Single Word Atomic";
};

opcode "l.ld" {
    with { O=0x20, D, A, I };
    input { I, A };
    output { D };
    display { D, I(A) };
    description "Load Double Word";
    limited { 64bit }; /* 64-bit only */
};

opcode "l.lwz" {
    with { O=0x21, D, A, I };
    input { I, A };
    output { D };
    display { D, I(A) };
    description "Load Single Word and Extend with Zero"; /* NTS: 32-bit, just loads the word. Extend only for 64-bit */
};

opcode "l.lws" {
    with { O=0x22, D, A, I };
    input { I, A };
    output { D };
    display { D, I(A) };
    description "Load Single Word and Extend with Sign"; /* NTS: 32-bit, just loads the word. Extend only for 64-bit */
};

opcode "l.lbz" {
    with { O=0x23, D, A, I };
    input { I, A };
    output { D };
    display { D, I(A) };
    description "Load Byte and Extend with Zero";
};

opcode "l.lbs" {
    with { O=0x24, D, A, I };
    input { I, A };
    output { D };
    display { D, I(A) };
    description "Load Byte and Extend with Sign";
};

opcode "l.lhz" {
    with { O=0x25, D, A, I };
    input { I, A };
    output { D };
    display { D, I(A) };
    description "Load Half Word and Extend with Zero";
};

opcode "l.lhs" {
    with { O=0x26, D, A, I };
    input { I, A };
    output { D };
    display { D, I(A) };
    description "Load Half Word and Extend with Sign";
};

