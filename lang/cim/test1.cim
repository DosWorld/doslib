-3, 4, 5, 6, 7, 8, +8, -9, -10, !2, !!2, ~2, 2+3, 2+3+4, 5+6-3-2, 2 + -3;
4 * 5, 4 * 3 * 2, 4 / 2, 4 / 2 / 2, 4 % 3;
4 + 3 * 5; 4 + 20 * 3 / 5; 4 + 3 * 4 + 5 * 8 + 2 * 2;
4 = 3; 1 = 2 = 3 = 4 = 5 + 6;
4 += 3; 4 += 5 = 6; 4 -= 6 * 8; 4 -= 6 += 4 = 7 * 3;
(4), (4 + 5 * 3), ((4 + 5 * 3) + 8) / 2;
4 *= 3 + 5 * 8;
4 /= 2 + 2;
4 %= 2;
4 ? 5 : 3;
4 + 3 ? 5 + 5 : 3 + 3;
4 + 3 * 5 ? 9 ? 1 : 2 : 2 * 5;
3 || 1;
1 || 2 + 3 || 3;
1 && 2;
1 && 2 || 3 && 4 || 5 * 8;
1|3; 1+4|3+3;
1^3; 1^3+4;
1&3; 3&1+2;
4 &= 3 + 4;
4 ^= 1 * 2;
4 |= 3 + 4;
3 == 4; 2 == 3 == 4; 2 * 2 == 4 == 8/2;
3 != 4;
3 < 4; 3 > 2; 3 <= 5; 6 >= 2; 3*3 < 8+8;
3 <<= 4 * 4; 3 >>= 4 + 4;
3 << 4; 1 >> 2; 3 << 2*2; 4 >> 4/2;
--3; ++4; --(3*5), 4; ++(3+8*2);
*4; *4*4; *4*6+2; *4 * *6; **4; **4 * ***6 + 3 * 8;
&4 * 3; &4 & 2; &4 & &3; 4++; 5--; (4*5)++; (2*3+4)--;
4 . 5; 4 . 2 . 4; 2 -> 4; 2 -> 3 -> 4; 2 . 3 -> 4;
4[1]; 4[5*8+3]; (3*5+8*2)[2*3+4]; 4[5][6][7][8]; (4[5*6]) + 3[7];
4(5,3,2,1); 4(); (4*3 + 5*8)(1,2*3+5,3*(2+4),4);
identifier; _identifier; _id123; _id1 + _id2 * _idmult1; a = 5; b = (a * 5) + a;
1.0, 2.2, -3.5, 3.3333333, 4e0, 0.4e1, 0.4e+1, 40e-1;
10, 0x10, 0b10, 010; 0, 00; 1u; 1l; 1ll; 1.0; 1.0f; 1.0d; 1.0l;
2; 123; 123'456; 123'456'78.12'34'567'89;
'a', 'b', '0', '\\', '\n', '\r', '\t', '\b', '\a', '\0', '\000', '\1', '\377', '\x01', '\xAA', '\xff';
'abcd', '\0\0\0\0', '\x10\x20\x30\x40\x50', 'this is a really long char constant';
L'w'; u'w'; U'w'; u8'w'; L'wah!'; u'unicode'; U'Unicode too!';
L'Unicode ‚Üí and ‚û§ string!'; u'Boxed ‚ñ†‚ñ†‚ñ† in'; U'Boxed ‚ñ†‚ñ†‚ñ† in'; U'Emoji too üòÄüòÑüòÅ'; u'Emoji too üòÄüòÑüòÅ'; u8'Emoji too ‚ñ†‚ñ†‚ñ† üòÄüòÑüòÅ';
"Hello world"; L"Hello world"; u8"Hello world";
"String " "concatenation"; "Multiple " "string " "concat" "enation";
L 'Unicode'; L "Unicode"; L      "Unicode"; u8         "Unicode";
H"<<_EOF
Hello
_EOF"; H"<<TESTING123
Hello world.
Multiple lines.
TESTING123"; LH"<<Fart
One line
Two line
fart, should not trigger
FART, should not trigger
 Fart, should not trigger
Fart, should not trigger. The next line will not either.
Fart
Okay, next will trigger.
Fart";
"Multiple" "string " H"<<CAT
concatenation but now
across multiple
CAT" " lines too";
HD"<<DOS
MS-DOS and Windows line encodings too.
CR LF encoding.
DOS";
HM"<<MAC
Classic Macintosh OS style line encodings.
CR encoding.
MAC";
HU"<<UNIX
Unix style encoding, which is default anyway.
LF encoding.
UNIX";
'\077', '\o{77}', '\x0f', '\x{f}', '\u00A0', '\u{A0}';
;;;
{ 4; 3; 3,4; }; { 4; "hello"; 5 * 3 + 2; }; { 4; { 5, 3, 8*4; }; 44; }; { 4; { 1, 2; 3; 4; }; }; { 4; 6; { 2; 5; 7; { 6; { 2, 3, 4; }; }; }; };
{ 4; 3; 3,4; }  { 4; "hello"; 5 * 3 + 2; }  { 4; { 5, 3, 8*4; }  44; }  { 4; { 1, 2; 3; 4; }  }  { 4; 6; { 2; 5; 7; { 6; { 2, 3, 4; }  }  }  }

{
	x = { 4, 3, 4 };
	x = { 4, 3, {8, 8*8, 8*8*8, 8*8*8*8}, 16 };
	x = { 1, 2, 3 }, { 4, 5, 6 };
	x = { 1, 2, 3 }, y = { 4, 5, 6};
}

let auto a = 40; /* a of default type */
let a b = 40; /* b of type a */

let int const a = 3;
let const int a = 3;
let int const a = 3, b = 5;
let const int a = 3, b = 5;

let int var1 = 45;
let signed int var2 = 123;
let signed long int var3 = 456l;
let signed long long int var4 = 789ll;

int func1();
int func1(void);
int func1(int x,char y,float f);
fn signed long long int func1(signed long long x,unsigned long long y);

fn int func1() {
	return(5);
};

fn int func1(int x,int y) {
	return(x*x + y);
};

fn signed long long int func1(signed long long int x,float y) {
	return(x*x*x + y);
};

fn int func1(int x,int y) {
	return (x + y);
}

fn signed long long int func1(signed long long int x,float y) {
	return(x*x*x + y);
}

fn int func1() {
	return 5;
};

fn int func1(int x,int y) {
	return x*x + y;
};

fn signed long long int func1(signed long long int x,float y) {
	return x*x*x + y;
};

fn int func1(int x,int y) {
	return x + y;
}

fn signed long long int func1(signed long long int x,float y) {
	return x*x*x + y;
}

fn void func1(void) {
	return;
}

fn int func1(int x,int y) {
	int z = func2(x,y,13);
	z += func3(y,x^y);
	return z ^ 1;
}

// C++ style comment. This should be ignored to end of line.
// Even if another // is in the line, ignored to end of line.
fn int func1(int x/*input code*/) {
	return x;/*return here /* okay? */ */
	/*/*/*/*This should be ignored*/ even */ if */ nested */
}

fn int func1(int x) {
	int x = /* multiple line comments,
	to describe something,
	are perfectly fine.

	Go ahead,

	Blather on*/ { 4, 5, 6 };
	return x[0];
}

fn int func1(float z) {
	int x = {z,z*2,z*3.14,z*4,z*5,z*6,z*7,z*8,z*9.99}; /* C99 syntax */
	int y = &x;
	return x[5];
}

fn int func1(float x) {
	return (int)x;
}

fn int func1(float x) {
	return (signed long int)x+(signed long int)(~x);
}

fn int func1(int x) {
	int x = (long){1*x,2*x,(long long)(3*x),4*x};
	return (int)((float)x * 1.23);
}

fn int func1(int x) {
	return (int)floatmul1(x,1.245);
}

fn int func1(float x) {
	return int(x); /* C++ style typecast */
}

fn int func1(float x) {
	return (signed long int)(x); /* C++ style typecast */
}

fn int func1(int x) {
	int z = 1;

again:	z++;
	goto again;
}

fn int func1(int x) {
	return x::y::z::a::b::c;
}

fn int func1(int x) {
	if (x == 3)
		return x*x;

	return x*3;
}

fn int func1(int x) {
	if (x == 3)
		return x*x;
	else
		return x*3;
}

fn int func1(int x) {
	if (x == 3)
		return x*x;
	else if (x == 5)
		return x*x*2;
	else
		return x*3;
}

fn int func1(int x) {
	if (x == 3)
		return x*x;
	else if (x == 5)
		return x*x*2;
	else if (x == 7)
		{ x += 7; return x*x*3; }
	else
		return x*3;
}

fn int func1(int x) {
	let int y = x ^ 1;

	switch (x) {
		y++; /* should be ignored */
		case 1: y ^= 3; break;
		case 2: y ^= 2; /* fall through */
		case 3: y ^= 4; break;
		default: y |= 8; break;
	}

	return y;
}

fn int func1(int x) {
	let int y = x ^ 1;

	switch (x) {
		y++; /* should be ignored */
		y += 2; /* should be ignored */
		case 1: y ^= 3; break;
		case 2: y ^= 2;
			switch (x&3) {
				case 1: y |= 32; break;
				case 3: y += 48; break;
			}
			break;
		case 3: y ^= 4; break;
		default: y |= 8; break;
	}

	while (x > 0) x--;

	while (x > 0) { x = (x << 1); y++; }

	while (x > 0) {
		x = (x << 1);
		if (x == 0x80) break;
		y++;
	}

	do {
		x = (x << 1) + 1; y += 2;
	} while (x < 0x100);

	do x = (x << 1) + 1; while (x < 0x200); /* not often used, but you can do statement without curly braces */

	for (;;);
	for (;;) {}
	for (x=0;x < 100;x++) y++;
	for (x=0;x < 100;) { y++; x += y; }
	for (x=0;x < 100;x += 3) { y++; x += y; }

a: b:	x += 3;
	goto a;

	switch (x) {
		case 1: case 2: case 3: y += 5; break;
	}

	a::b::c d::e::f(5,x::y::z);

	let auto x;
	let int x;
	let signed long int x;
	let signed long long int x;
	let auto x = 5;
	let int x = 5;
	let signed long int x = 5;
	let auto x = 5 + 5 * 3;
	let int x = a * b + c;
	let int x = 1;
	let signed long int x = 1;
	let auto x = 5;
	let x::y x = 6;
	let a::b x::y = 6;
	let const int x = 2;
	let const int x = a::b * c::d;
	let auto x,y;
	let int x,y,z;
	let signed long int x,y,z;
	let signed long int x = 1,y = 2,z = 3;
	let auto *x = 5;
	let int *x = 5;
	let auto *x;
	let signed long int *x = 1;
	let signed long int **x = 1;
	let int ** x = &z;
	let int * int * x = &z;
	let const int * const * const ** x = &z;
	let signed long int &x = 1;
	let int &x = z;
	let int &&x = z;
	let int &&&x = z + 4 + x*x;
	let char *x;
	let char *x = &z;
	let const int *x = &z;
	let const int * const x = &z;
	let const int **x = &z;
	let const int &x = z;
	let const int &&x = z;
	let const int & const &x = z;
	let const int && const &x = z;
	let const int *x const const *x = &z;
	let volatile int * volatile * volatile const x = &z;
	let const int scoped::t * const &x::y;
	let auto x,y,z;
	let int x,y,z;
	let auto x = 4,y = 5,*z = 6;
	let int x = 4,y = 5,*z = 6;
	let const int x = 4,y = 5,*z = 6;
	let const char * const x = 3,y = 4;
	return y;
}

fn func1;
fn int func1;
fn int* func1;
fn int** func1;
fn int* const func1;
fn int* const * const * func1;
fn int& func1;
fn int&& func1;
fn int& & func1;
fn int&& & func1;
fn int* && * & func1;
fn func1(void);
fn func1(int x,long y);
fn int* func1(int x,long y,float z);
fn signed long int * const * func1(int x,long y,float z);

fn func1(int x,int y) {
	return x+y;
}

fn long func1(int x,int y) {
	return x+y;
}

fn signed long int func1(int x,int y) {
	return x+y;
}

fn signed long int ** func1(int *x,int **y) {
	return *x + **y;
}

fn signed long int func1(int &x,signed long int y) {
	return x + y;
}

fn signed long long func1(int,long,float) {
	return -1ll;
}

let auto abc;
let int x = a * b + 5;
let char *a,b,c;

fn func1;
fn func1();
fn int func1(void);
fn signed long long func1(int x,float y,signed long int z);
fn constexpr const int func1(const unsigned int x) {
	return ~x;
}
fn static constexpr const int func1(const unsigned int x) {
	return ~x;
}
fn compileexpr const int func1(const unsigned int x) {
	return ~x;
}
fn static compileexpr const int func1(const unsigned int x) {
	return ~x;
}
fn extern const int func1(const unsigned int x);
fn const int func1(const auto x) {
	let auto y = ~x;
	return y + 2;
}

fn int func1(int x,...) {
	return x;
}

fn int func1(int x,*,int y,int abcxyz=0) {
	return x + y + abcxyz;
}

fn int func2(int a) {
	return func1(x:1,y:2*3+5,a+5*3-2/1);
}

fn int func2(int a,int b,int c) {
	return func1(x:a,y:b+c,abcxyz:b*c-a);
}

/* include() is reserved only when used as a function call.

   include()             reserved
   scope::include        not reserved
   structinst.include    not reserved
   structptr->include    not reserved */

include("duh");
scope::include("duh");
scope1::scope2::include("duh");
scope1::scope2::scope3::include("duh");
structinst.include("duh");
structptr->include("duh");
let int include = 5;
let size_t sz1 = sizeof(int);
let size_t sz2 = sizeof(sz1) + sizeof(int);
let ssize_t sz1 = sizeof(int) - sizeof(char);
let ssize_t sz1 = 5 - sizeof(char);
let ssize_t sz1 = (ssize_t)(5 - (size_t)sizeof(char));
let ssize_t sz1 = ssize_t(5 - size_t(sizeof(char))); /* allow C++ style too, which at first looks like a function call, but later stages will know the "function" is a data type and therefore a typecast */
let size_t of1 = offsetof(somestruct,member1);
let size_t of2 = offsetof(somestruct,member2) - offsetof(somestruct,member1);
static_assert(sizeof(of1) == sizeof(size_t), "oops");
static_assert(sizeof(of1) == sizeof(size_t));
let typedef int x; /* <- todo: allow "typedef" without "let" */
let using x = 4; /* <- todo: implement "using" properly */
let namespace x = 4; /* <- todo: implement "namespace" properly */

